# Programmers.Level2_Java_Joystick

## 프로그래머스 Greedy > 조이스틱

### 1. 문제설명
문제: https://programmers.co.kr/learn/courses/30/lessons/42860

input으로 name이라는 문자열이 들어온다. 조이스틱을 이용하여 name과 같은 문자열을 만들기 위한 최소 조작 횟수값을 return하는 문제이다. 조이스틱으로 만들 초기 String의 값은 name과 같은 길이에 모든 문자열이 A로 초기화된 문자열이다. 커서의 위치는 첫 문자에서 시작된다.
> ↑ : 다음알파벳 
> ↓ : 이전알파벳(A에서 이동시 Z로)
> ← : 커서를 왼쪽으로 이동 (첫 번째 위치에서 이동시 마지막 문자로)
> → : 커서를 오른쪽으로 이동

### 2. 풀이
문제를 풀면서 알게되었다. 이 문제는 완벽한 문제가 아니며 최적해가 정답이아니라서 최적해를 구해도 오답이다...

정답이 되기 위해서는 첫번째 문자로부터 왼쪽 또는 오른쪽으로 방향을 정한 후 방향을 변하지 않게 같은 방향으로 이동시키며 문자를 바꾸는 알고리즘을 작성해야하며 이는 최소값이아니다.

먼저 조이스틱의 상하 조작횟수를 계산했다. A로만 구성된 문자열을 생성하고 char형으로 String의 한 문자마다 차이를 계산하여 int[] comp를 만들었고 이 배열의 모든 원소의 합으로 조작횟수를 계산했다.

최적해를 구하기 위한 문제접근은 comp를 두개 이어붙여서 진행하였다.
```int[] comp = {1, 0, 2, 5};```라면 (첫번째 인덱스를 삭제한 0 2 5) + (1 0 2 5) => ```int[] arr = {0, 2, 5, 1, 0, 2, 5}``` 로 만들었고, 커서의 위치는 중앙으로 두었다. 커서가 이동될 때 마다 comp = 0 으로 만들며 이는 해당 위치에서 조이스틱이 상하 조작을 마쳤다는 것을 의미한다. 문제는 좌우중 어디로 먼저 진행할 것이냐인데 후보는 이렇게 정하였다.

startIdx를 기준으로 연속해서 인접한0값이 나온 후 0이아닌 원소가 나왔을 때, 이후 0이 나오기 직전 index값까지 이동시키는 횟수를 구하고 그 횟수가 최소인곳으로 방향을 움직이게 하였다.

이런 접근은 디스크 스케줄러에서 최소 scan time을 가지게 하는 문제와 유사하게 볼 수 있다.

0 2 5 (0) 0 2 5

커서의 위치가 ()일 때 왼쪽으로의 이동횟수는 5 2 로 두번이며 오른쪽으로의 이동횟수는 0 2 5 로 세번이 됨을 알 수 있다. 오른쪽 방향의 0 은 인접한 0이므로 제외한 후 배열의 끝까지 가기전 0이 나오지 않아 마지막 index까지 이동한 횟수이다.

왼쪽이 2번, 오른쪽이 3번이므로 최소로 이동할 수 있는 왼쪽으로 2번이동한 후 위의 과정을 반복한다.

반복은 arr에서 연속된 0의 갯수가 name.length만큼 존재한다면 중지하도록 하였고 반복 과정시 움직이는 커서의 횟수는 누적하여 가지고있다 위아래 조작횟수와 더하여 총 조작횟수를 return해 주어 해결했다.
